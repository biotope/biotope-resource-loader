(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.resourceLoader = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var keys = createCommonjsModule(function (module, exports) {
	exports = module.exports = typeof Object.keys === 'function'
	  ? Object.keys : shim;

	exports.shim = shim;
	function shim (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	});
	var keys_1 = keys.shim;

	var is_arguments = createCommonjsModule(function (module, exports) {
	var supportsArgumentsClass = (function(){
	  return Object.prototype.toString.call(arguments)
	})() == '[object Arguments]';

	exports = module.exports = supportsArgumentsClass ? supported : unsupported;

	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}
	exports.unsupported = unsupported;
	function unsupported(object){
	  return object &&
	    typeof object == 'object' &&
	    typeof object.length == 'number' &&
	    Object.prototype.hasOwnProperty.call(object, 'callee') &&
	    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
	    false;
	}});
	var is_arguments_1 = is_arguments.supported;
	var is_arguments_2 = is_arguments.unsupported;

	var deepEqual_1 = createCommonjsModule(function (module) {
	var pSlice = Array.prototype.slice;



	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();

	  // 7.3. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
	    return opts.strict ? actual === expected : actual == expected;

	  // 7.4. For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	};

	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}

	function isBuffer (x) {
	  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}

	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (is_arguments(a)) {
	    if (!is_arguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = keys(a),
	        kb = keys(b);
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return typeof a === typeof b;
	}
	});

	if (typeof Object.assign !== 'function') {
	  // Must be writable: true, enumerable: false, configurable: true
	  Object.defineProperty(Object, 'assign', {
	    value: function assign(target, varArgs) {
	      if (target === null) {
	        // TypeError if undefined or null
	        throw new TypeError('Cannot convert undefined or null to object');
	      }

	      const to = Object(target);

	      for (let index = 1; index < arguments.length; index++) {
	        const nextSource = arguments[index];

	        if (nextSource !== null) {
	          // Skip over if undefined or null
	          for (const nextKey in nextSource) {
	            // Avoid bugs when hasOwnProperty is shadowed
	            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey))
	              to[nextKey] = nextSource[nextKey];
	          }
	        }
	      }
	      return to;
	    },
	    writable: true,
	    configurable: true
	  });
	}

	const makeId = () => {
	  let text = '';
	  const possible =
			'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
	  for (let i = 0; i < 8; i += 1) {
	    text += possible.charAt(Math.floor(Math.random() * possible.length));
	  }
	  return text;
	};

	function getOrigin() {
	  if (!window.location.origin) {
	    return (window.location.origin =
				window.location.protocol +
				'//' +
				window.location.hostname +
				(window.location.port ? ':' + window.location.port : ''));
	  }
	  return window.location.origin;
	}

	function absolutePath(urlString) {
	  let normalizedUrl;
	  const absoluteReg = new RegExp('^(?:[a-z]+:)?//', 'i');

	  if (absoluteReg.test(urlString)) {
	    // is absolute
	    normalizedUrl = urlString;
	  } else {
	    if (urlString.indexOf('/') === 0 && urlString.indexOf('//') !== 0) {
	      normalizedUrl = getOrigin() + urlString;
	    } else {
	      const paths = window.location.pathname.split('/');
	      paths.pop();
	      normalizedUrl = getOrigin() + paths.join('/') + '/' + urlString;
	    }
	  }
	  return normalizedUrl;
	}

	function getPath(path, resource, options) {
	  const pathIsRelative =
			path.indexOf('http://') === -1 &&
			path.indexOf('https://') === -1 &&
			path.charAt(0) !== '/';

	  // resolve relative paths
	  if (pathIsRelative) {
	    if (resource.base) {
	      if (resource.base.substring(0, 2) === '##')
	        resource.base = options.baseMap[resource.base];

	      path = resource.base + path;
	    } else if (options && options.base) {
	      path = options.base + path;
	    }
	  }
	  // create unique absolute path
	  const normalizedPath = absolutePath(path);

	  return normalizedPath;
	}

	/**
	 * VI Resource Loader v1.3.0
	 * For documentation see:
	 * https://github.com/biotope/biotope-resource-loader
	 */

	const checkDependencies = resources => {
	  const allPaths = [];
	  const dependencies = [];
	  // loop over resources object
	  for (const resource of resources) {
	    // take every resource object and loop over it's path's
	    for (const paths of resource.resources) {
	      // add path to allPaths
	      for (const path of paths.paths) {
	        allPaths.push(path);
	      }
	      // if has a dependency add it
	      if (paths.dependsOn) {
	        for (const dependency of paths.dependsOn) {
	          dependencies.push(dependency);
	        }
	      }
	    }
	  }
	  // check if dependencies are resolvable
	  for (const dependency of dependencies) {
	    if (allPaths.indexOf(dependency) === -1) {
	      console.error(`âš ï¸ ERROR ${dependency} not resolvable.`);
	    }
	  }
	};

	const checkDependency = (dependents, requests) => {
	  for (const d of dependents) {
	    const result = requests.find(r => r.path === d);
	    if (result === undefined) {
	      // not all dependencies are lined up
	      return false;
	    }
	  }
	  // all dependencies are lined up
	  return true;
	};

	const uniquePath = (requests, path, hasDependencies, sourceId, id) => {
	  const r = requests;
	  const result = requests.findIndex(r => r.path === path);
	  if (result === -1) {
	    r.push({ path, hasDependencies, sourceIds: [sourceId], packageIds: [id] });
	  } else {
	    r[result].sourceIds.push(sourceId);
	    r[result].packageIds.push(id);
	  }
	  return r;
	};

	const recurse = (arr, requests, counter = 0) => {
	  // recursive function to get load order
	  let req = requests;
	  const el = arr[0];
	  const arra = arr;
	  let i = counter; // counter counts up every unsuccessful reordering and resets itself on success.
	  // if first element has depndecies and dependencies are not in load order yet and the total length of the array is greater/equal to 2 + counter
	  if (
	    el.dependsOn &&
			checkDependency(el.dependsOn, req) === false &&
			arra.length >= 2 + counter
	  ) {
	    i = i + 1; // counter get up
	    const current = arr[0];
	    const next = arr[i];
	    arra[0] = next;
	    arra[i] = current;
	  } else {
	    // first item get's removed
	    arra.splice(0, 1);
	    // reset counter
	    i = 0;
	    let hasDependencies = false;
	    if (el.dependsOn && el.dependsOn.length > 0) {
	      hasDependencies = true;
	    }
	    // push all paths
	    for (const p of el.paths) {
	      req = uniquePath(req, p, hasDependencies, el.sourceId, el.id);
	    }
	  }
	  // if array not empty go for it again ðŸƒâ€
	  if (arra.length !== 0) {
	    return recurse(arr, req, i);
	  } else {
	    // return ordered requests.
	    return req;
	  }
	};

	const addToQueue = arr => {
	  const requests = [];
	  return recurse(arr, requests);
	};

	function flattenQueue(resources) {
	  const flatten = [];
	  for (const resourceTree of resources) {
	    for (const ast of resourceTree.resources) {
	      ast.sourceId = resourceTree.id;
	      flatten.push(ast);
	    }
	  }
	  return flatten;
	}

	const getResourcesFromDOM = (selector, options) => {
	  // thats an array of all resources found in the dom
	  const resources = [];
	  // Array of HTML elements with a dataset "resources"
	  let domResources = null;
	  // if no selector is specified the scope is the whole document
	  if (selector !== '') {
	    const container = document.querySelector(selector);
	    domResources = [].slice.call(
	        container.querySelectorAll('[data-resources]')
	    );
	  } else {
	    domResources = [].slice.call(document.querySelectorAll('[data-resources]'));
	  }
	  for (const newResource of domResources) {
	    const obj = {};
	    // evaluating data attribute string
	    obj.resources = eval(newResource.dataset.resources);
	    // normalize path
	    for (const key in obj.resources) {
	      const resourceObj = obj.resources[key];
	      resourceObj.id = makeId();
	      for (const pathKey in resourceObj.paths) {
	        const path = resourceObj.paths[pathKey];
	        obj.resources[key].paths[pathKey];
	        obj.resources[key].paths[pathKey] = getPath(path, resourceObj, options);
	      }
	      if (resourceObj.dependsOn) {
	        for (const dependsOnKey in resourceObj.dependsOn) {
	          const path = resourceObj.dependsOn[dependsOnKey];
	          obj.resources[key].dependsOn[dependsOnKey] = getPath(
	              path,
	              resourceObj,
	              options
	          );
	        }
	      }
	    }
	    // resource or combination is new
	    let isNew = true;
	    // find duplicates ðŸ‘­
	    if (resources.length > 0) {
	      for (const resource of resources) {
	        // TODO âš ï¸ Thats a bug right here because of unique ids
	        if (deepEqual_1(resource.resources, obj.resources)) {
	          // if not new set to false, add class and break
	          newResource.classList.add(`resourceLoader-${resource.id}`);
	          isNew = false;
	          break;
	        }
	      }
	    }
	    if (isNew) {
	      obj.id = makeId();
	      newResource.classList.add(`resourceLoader-${obj.id}`);
	      resources.push(obj);
	    }
	  }
	  return resources;
	};

	const prewarmCache = path => {
	  fetch(path);
	};

	const attachToDom = dependency => {
	  const type = dependency.path.indexOf('.css') > -1 ? 'css' : 'js';
	  if (type === 'css') {
	    fetch(dependency.path).then(() => {
	      const style = document.createElement('link');
	      style.rel = 'stylesheet';
	      style.async = true;
	      style.href = dependency.path;
	      document.body.append(style);
	      style.addEventListener('load', () => {
	        // console.log('ðŸ’… style ready', style);
	        const e = new CustomEvent('resourceLoaded', { detail: dependency });
	        document.dispatchEvent(e);
	      });
	    });
	  } else {
	    const script = document.createElement('script');
	    script.src = dependency.path;
	    script.async = true;
	    document.body.append(script);
	    script.addEventListener('load', () => {
	      // console.log('ðŸ“– script ready', script);
	      const e = new CustomEvent('resourceLoaded', { detail: dependency });
	      document.dispatchEvent(e);
	    });
	  }
	};

	const makeRequests = (urls, byPassCache = false) => {
	  for (const url of urls) {
	    if (url.hasDependencies && !byPassCache) {
	      prewarmCache(url.path);
	    } else {
	      attachToDom(url);
	    }
	  }
	};

	const markAsDone = (readyResources, pkg) => {
	  const ready = readyResources;
	  for (const readySource of ready) {
	    const { id, resources } = readySource;
	    if (id === pkg.sourceId) {
	      for (const sourcePkgKey in resources) {
	        if (pkg.id === resources[sourcePkgKey].id) {
	          resources.splice(sourcePkgKey, 1);
	          if (resources.length === 0) {
	            const e = new CustomEvent('resourceReady', { detail: id });
	            document.dispatchEvent(e);
	          }
	        }
	      }
	    }
	  }
	  return ready;
	};

	let debug = null;

	const defaults = {
	  container: '', // css selector for document.querySelector
	  readyEvent: 'resourcesReady' // needs to be a string
	};

	let resources = [];

	// global options
	let options = null;

	const resourceLoader = customOptions => {
	  options = Object.assign({}, defaults, customOptions);
	  debug = options.debug ? options.debug : true;

	  resources = getResourcesFromDOM(options.container, options);
	  // ðŸ‘·â€ add resources from options to queue
	  if (options.resources) {
	    resources.unshift({ resources: options.resources });
	  }
	  // collect data structures
	  checkDependencies(resources);
	  const whatever = flattenQueue(resources);
	  const requests = addToQueue(whatever);
	  makeRequests(requests);
	  const packages = flattenQueue(resources);
	  let readyResources = resources.slice(0);
	  document.addEventListener('resourceLoaded', e => {
	    for (const pkgKey in packages) {
	      const pkg = packages[pkgKey];
	      if (pkg.dependsOn && pkg.dependsOn.length > 0) {
	        const index = pkg.dependsOn.indexOf(e.detail.path);
	        if (index > -1) {
	          pkg.dependsOn.splice(index, 1);
	          if (pkg.dependsOn.length === 0) {
	            makeRequests(addToQueue([pkg]), true);
	          }
	        }
	      } else {
	        const index = pkg.paths.indexOf(e.detail.path);
	        if (index > -1) {
	          pkg.paths.splice(index, 1);
	          if (pkg.paths.length === 0) {
	            readyResources = markAsDone(readyResources, pkg);
	          }
	        }
	      }
	    }
	  });
	  let counter = 0;
	  document.addEventListener('resourceReady', e => {
	    counter = counter + 1;
	    if (counter === readyResources.length) {
	      console.log('all done', options.readyEvent);
	      const ev = new CustomEvent('resourcesReady');
	      document.dispatchEvent(ev);
	    }
	  });
	  document.addEventListener('resourcesReady', e => {
	    console.log('all ok');
	  });
	};

	return resourceLoader;

})));
