(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.resourceLoader = factory());
}(this, (function () { 'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var PROXY_STATE = typeof Symbol !== "undefined" ? Symbol("immer-proxy-state") : "__$immer_state";

  var RETURNED_AND_MODIFIED_ERROR = "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.";

  function verifyMinified() {}

  var inProduction = typeof process !== "undefined" && process.env.NODE_ENV === "production" || verifyMinified.name !== "verifyMinified";

  var autoFreeze = !inProduction;
  var useProxies = typeof Proxy !== "undefined";

  function getUseProxies() {
      return useProxies;
  }

  function isProxy(value) {
      return !!value && !!value[PROXY_STATE];
  }

  function isProxyable(value) {
      if (!value) return false;
      if ((typeof value === "undefined" ? "undefined" : _typeof(value)) !== "object") return false;
      if (Array.isArray(value)) return true;
      var proto = Object.getPrototypeOf(value);
      return proto === null || proto === Object.prototype;
  }

  function freeze(value) {
      if (autoFreeze) {
          Object.freeze(value);
      }
      return value;
  }

  function shallowCopy(value) {
      if (Array.isArray(value)) return value.slice();
      if (value.__proto__ === undefined) return Object.assign(Object.create(null), value);
      return Object.assign({}, value);
  }

  function each(value, cb) {
      if (Array.isArray(value)) {
          for (var i = 0; i < value.length; i++) {
              cb(i, value[i]);
          }
      } else {
          for (var key in value) {
              cb(key, value[key]);
          }
      }
  }

  function has(thing, prop) {
      return Object.prototype.hasOwnProperty.call(thing, prop);
  }

  // given a base object, returns it if unmodified, or return the changed cloned if modified
  function finalize(base) {
      if (isProxy(base)) {
          var state = base[PROXY_STATE];
          if (state.modified === true) {
              if (state.finalized === true) return state.copy;
              state.finalized = true;
              return finalizeObject(useProxies ? state.copy : state.copy = shallowCopy(base), state);
          } else {
              return state.base;
          }
      }
      finalizeNonProxiedObject(base);
      return base;
  }

  function finalizeObject(copy, state) {
      var base = state.base;
      each(copy, function (prop, value) {
          if (value !== base[prop]) copy[prop] = finalize(value);
      });
      return freeze(copy);
  }

  function finalizeNonProxiedObject(parent) {
      // If finalize is called on an object that was not a proxy, it means that it is an object that was not there in the original
      // tree and it could contain proxies at arbitrarily places. Let's find and finalize them as well
      if (!isProxyable(parent)) return;
      if (Object.isFrozen(parent)) return;
      each(parent, function (i, child) {
          if (isProxy(child)) {
              parent[i] = finalize(child);
          } else finalizeNonProxiedObject(child);
      });
      // always freeze completely new data
      freeze(parent);
  }



  function is(x, y) {
      // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
      if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
      } else {
          return x !== x && y !== y;
      }
  }

  // @ts-check

  var proxies = null;

  var objectTraps = {
      get: get$1,
      has: function has$$1(target, prop) {
          return prop in source(target);
      },
      ownKeys: function ownKeys(target) {
          return Reflect.ownKeys(source(target));
      },

      set: set$1,
      deleteProperty: deleteProperty,
      getOwnPropertyDescriptor: getOwnPropertyDescriptor,
      defineProperty: defineProperty$1,
      setPrototypeOf: function setPrototypeOf() {
          throw new Error("Don't even try this...");
      }
  };

  var arrayTraps = {};
  each(objectTraps, function (key, fn) {
      arrayTraps[key] = function () {
          arguments[0] = arguments[0][0];
          return fn.apply(this, arguments);
      };
  });

  function createState(parent, base) {
      return {
          modified: false,
          finalized: false,
          parent: parent,
          base: base,
          copy: undefined,
          proxies: {}
      };
  }

  function source(state) {
      return state.modified === true ? state.copy : state.base;
  }

  function get$1(state, prop) {
      if (prop === PROXY_STATE) return state;
      if (state.modified) {
          var value = state.copy[prop];
          if (value === state.base[prop] && isProxyable(value))
              // only create proxy if it is not yet a proxy, and not a new object
              // (new objects don't need proxying, they will be processed in finalize anyway)
              return state.copy[prop] = createProxy(state, value);
          return value;
      } else {
          if (has(state.proxies, prop)) return state.proxies[prop];
          var _value = state.base[prop];
          if (!isProxy(_value) && isProxyable(_value)) return state.proxies[prop] = createProxy(state, _value);
          return _value;
      }
  }

  function set$1(state, prop, value) {
      if (!state.modified) {
          if (prop in state.base && is(state.base[prop], value) || has(state.proxies, prop) && state.proxies[prop] === value) return true;
          markChanged(state);
      }
      state.copy[prop] = value;
      return true;
  }

  function deleteProperty(state, prop) {
      markChanged(state);
      delete state.copy[prop];
      return true;
  }

  function getOwnPropertyDescriptor(state, prop) {
      var owner = state.modified ? state.copy : has(state.proxies, prop) ? state.proxies : state.base;
      var descriptor = Reflect.getOwnPropertyDescriptor(owner, prop);
      if (descriptor && !(Array.isArray(owner) && prop === "length")) descriptor.configurable = true;
      return descriptor;
  }

  function defineProperty$1() {
      throw new Error("Immer does currently not support defining properties on draft objects");
  }

  function markChanged(state) {
      if (!state.modified) {
          state.modified = true;
          state.copy = shallowCopy(state.base);
          // copy the proxies over the base-copy
          Object.assign(state.copy, state.proxies); // yup that works for arrays as well
          if (state.parent) markChanged(state.parent);
      }
  }

  // creates a proxy for plain objects / arrays
  function createProxy(parentState, base) {
      var state = createState(parentState, base);
      var proxy = Array.isArray(base) ? Proxy.revocable([state], arrayTraps) : Proxy.revocable(state, objectTraps);
      proxies.push(proxy);
      return proxy.proxy;
  }

  function produceProxy(baseState, producer) {
      var previousProxies = proxies;
      proxies = [];
      try {
          // create proxy for root
          var rootProxy = createProxy(undefined, baseState);
          // execute the thunk
          var returnValue = producer.call(rootProxy, rootProxy);
          // and finalize the modified proxy
          var result = void 0;
          // check whether the draft was modified and/or a value was returned
          if (returnValue !== undefined && returnValue !== rootProxy) {
              // something was returned, and it wasn't the proxy itself
              if (rootProxy[PROXY_STATE].modified) throw new Error(RETURNED_AND_MODIFIED_ERROR);

              // See #117
              // Should we just throw when returning a proxy which is not the root, but a subset of the original state?
              // Looks like a wrongly modeled reducer
              result = finalize(returnValue);
          } else {
              result = finalize(rootProxy);
          }
          // revoke all proxies
          each(proxies, function (_, p) {
              return p.revoke();
          });
          return result;
      } finally {
          proxies = previousProxies;
      }
  }

  // @ts-check

  var descriptors = {};
  var states = null;

  function createState$1(parent, proxy, base) {
      return {
          modified: false,
          hasCopy: false,
          parent: parent,
          base: base,
          proxy: proxy,
          copy: undefined,
          finished: false,
          finalizing: false,
          finalized: false
      };
  }

  function source$1(state) {
      return state.hasCopy ? state.copy : state.base;
  }

  function _get(state, prop) {
      assertUnfinished(state);
      var value = source$1(state)[prop];
      if (!state.finalizing && value === state.base[prop] && isProxyable(value)) {
          // only create a proxy if the value is proxyable, and the value was in the base state
          // if it wasn't in the base state, the object is already modified and we will process it in finalize
          prepareCopy(state);
          return state.copy[prop] = createProxy$1(state, value);
      }
      return value;
  }

  function _set(state, prop, value) {
      assertUnfinished(state);
      if (!state.modified) {
          if (is(source$1(state)[prop], value)) return;
          markChanged$1(state);
          prepareCopy(state);
      }
      state.copy[prop] = value;
  }

  function markChanged$1(state) {
      if (!state.modified) {
          state.modified = true;
          if (state.parent) markChanged$1(state.parent);
      }
  }

  function prepareCopy(state) {
      if (state.hasCopy) return;
      state.hasCopy = true;
      state.copy = shallowCopy(state.base);
  }

  // creates a proxy for plain objects / arrays
  function createProxy$1(parent, base) {
      var proxy = shallowCopy(base);
      each(base, function (i) {
          Object.defineProperty(proxy, "" + i, createPropertyProxy("" + i));
      });
      var state = createState$1(parent, proxy, base);
      createHiddenProperty(proxy, PROXY_STATE, state);
      states.push(state);
      return proxy;
  }

  function createPropertyProxy(prop) {
      return descriptors[prop] || (descriptors[prop] = {
          configurable: true,
          enumerable: true,
          get: function get$$1() {
              return _get(this[PROXY_STATE], prop);
          },
          set: function set$$1(value) {
              _set(this[PROXY_STATE], prop, value);
          }
      });
  }

  function assertUnfinished(state) {
      if (state.finished === true) throw new Error("Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process?");
  }

  // this sounds very expensive, but actually it is not that extensive in practice
  // as it will only visit proxies, and only do key-based change detection for objects for
  // which it is not already know that they are changed (that is, only object for which no known key was changed)
  function markChanges() {
      // intentionally we process the proxies in reverse order;
      // ideally we start by processing leafs in the tree, because if a child has changed, we don't have to check the parent anymore
      // reverse order of proxy creation approximates this
      for (var i = states.length - 1; i >= 0; i--) {
          var state = states[i];
          if (state.modified === false) {
              if (Array.isArray(state.base)) {
                  if (hasArrayChanges(state)) markChanged$1(state);
              } else if (hasObjectChanges(state)) markChanged$1(state);
          }
      }
  }

  function hasObjectChanges(state) {
      var baseKeys = Object.keys(state.base);
      var keys = Object.keys(state.proxy);
      return !shallowEqual(baseKeys, keys);
  }

  function hasArrayChanges(state) {
      var proxy = state.proxy;

      if (proxy.length !== state.base.length) return true;
      // See #116
      // If we first shorten the length, our array interceptors will be removed.
      // If after that new items are added, result in the same original length,
      // those last items will have no intercepting property.
      // So if there is no own descriptor on the last position, we know that items were removed and added
      // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check
      // the last one
      var descriptor = Object.getOwnPropertyDescriptor(proxy, proxy.length - 1);
      // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)
      if (descriptor && !descriptor.get) return true;
      // For all other cases, we don't have to compare, as they would have been picked up by the index setters
      return false;
  }

  function produceEs5(baseState, producer) {
      var prevStates = states;
      states = [];
      try {
          // create proxy for root
          var rootProxy = createProxy$1(undefined, baseState);
          // execute the thunk
          var returnValue = producer.call(rootProxy, rootProxy);
          // and finalize the modified proxy
          each(states, function (_, state) {
              state.finalizing = true;
          });
          // find and mark all changes (for parts not done yet)
          // TODO: store states by depth, to be able guarantee processing leaves first
          markChanges();
          var result = void 0;
          // check whether the draft was modified and/or a value was returned
          if (returnValue !== undefined && returnValue !== rootProxy) {
              // something was returned, and it wasn't the proxy itself
              if (rootProxy[PROXY_STATE].modified) throw new Error(RETURNED_AND_MODIFIED_ERROR);
              result = finalize(returnValue);
          } else result = finalize(rootProxy);
          // make sure all proxies become unusable
          each(states, function (_, state) {
              state.finished = true;
          });
          return result;
      } finally {
          states = prevStates;
      }
  }

  function shallowEqual(objA, objB) {
      //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
      if (is(objA, objB)) return true;
      if ((typeof objA === "undefined" ? "undefined" : _typeof(objA)) !== "object" || objA === null || (typeof objB === "undefined" ? "undefined" : _typeof(objB)) !== "object" || objB === null) {
          return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return false;
      for (var i = 0; i < keysA.length; i++) {
          if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
              return false;
          }
      }
      return true;
  }

  function createHiddenProperty(target, prop, value) {
      Object.defineProperty(target, prop, {
          value: value,
          enumerable: false,
          writable: true
      });
  }

  /**
   * produce takes a state, and runs a function against it.
   * That function can freely mutate the state, as it will create copies-on-write.
   * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned
   *
   * @export
   * @param {any} baseState - the state to start with
   * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
   * @returns {any} a new state, or the base state if nothing was modified
   */
  function produce(baseState, producer) {
      // prettier-ignore
      if (arguments.length !== 1 && arguments.length !== 2) throw new Error("produce expects 1 or 2 arguments, got " + arguments.length);

      // curried invocation
      if (typeof baseState === "function") {
          // prettier-ignore
          if (typeof producer === "function") throw new Error("if first argument is a function (curried invocation), the second argument to produce cannot be a function");

          var initialState = producer;
          var recipe = baseState;

          return function () {
              var args = arguments;

              var currentState = args[0] === undefined && initialState !== undefined ? initialState : args[0];

              return produce(currentState, function (draft) {
                  args[0] = draft; // blegh!
                  return recipe.apply(draft, args);
              });
          };
      }

      // prettier-ignore
      {
          if (typeof producer !== "function") throw new Error("if first argument is not a function, the second argument to produce should be a function");
      }

      // if state is a primitive, don't bother proxying at all and just return whatever the producer returns on that value
      if ((typeof baseState === "undefined" ? "undefined" : _typeof(baseState)) !== "object" || baseState === null) return producer(baseState);
      if (!isProxyable(baseState)) throw new Error("the first argument to an immer producer should be a primitive, plain object or array, got " + (typeof baseState === "undefined" ? "undefined" : _typeof(baseState)) + ": \"" + baseState + "\"");
      return getUseProxies() ? produceProxy(baseState, producer) : produceEs5(baseState, producer);
  }
  //# sourceMappingURL=immer.module.js.map

  if (typeof Object.assign !== 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, 'assign', {
      value: function assign(target, varArgs) {
        if (target === null) {
          // TypeError if undefined or null
          throw new TypeError('Cannot convert undefined or null to object');
        }

        const to = Object(target);

        for (let index = 1; index < arguments.length; index++) {
          const nextSource = arguments[index];

          if (nextSource !== null) {
            // Skip over if undefined or null
            for (const nextKey in nextSource) {
              // Avoid bugs when hasOwnProperty is shadowed
              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey))
                to[nextKey] = nextSource[nextKey];
            }
          }
        }
        return to;
      },
      writable: true,
      configurable: true
    });
  }

  const prewarmCache = path => {
    fetch(path);
  };

  const attachToDom = dependency => {
    const type = dependency.path.indexOf('.css') > -1 ? 'css' : 'js';
    if (type === 'css') {
      fetch(dependency.path).then(() => {
        const style = document.createElement('link');
        style.rel = 'stylesheet';
        style.async = true;
        style.href = dependency.path;
        document.body.append(style);
        style.addEventListener('load', () => {
          // console.log('💅 style ready', style);
          const e = new CustomEvent('packageLoaded', { detail: dependency });
          document.dispatchEvent(e);
        });
      });
    } else {
      const script = document.createElement('script');
      script.src = dependency.path;
      script.async = true;
      document.body.append(script);
      script.addEventListener('load', () => {
        // console.log('📖 script ready', script);
        const e = new CustomEvent('packageLoaded', { detail: dependency });
        document.dispatchEvent(e);
      });
    }
  };

  const getPackages = (urls, byPassCache = false) => {
    for (const url of urls) {
      if (url.hasDependencies && !byPassCache) {
        prewarmCache(url.path);
      } else {
        attachToDom(url);
      }
    }
  };

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var keys = createCommonjsModule(function (module, exports) {
  exports = module.exports = typeof Object.keys === 'function'
    ? Object.keys : shim;

  exports.shim = shim;
  function shim (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
  }
  });
  var keys_1 = keys.shim;

  var is_arguments = createCommonjsModule(function (module, exports) {
  var supportsArgumentsClass = (function(){
    return Object.prototype.toString.call(arguments)
  })() == '[object Arguments]';

  exports = module.exports = supportsArgumentsClass ? supported : unsupported;

  exports.supported = supported;
  function supported(object) {
    return Object.prototype.toString.call(object) == '[object Arguments]';
  }
  exports.unsupported = unsupported;
  function unsupported(object){
    return object &&
      typeof object == 'object' &&
      typeof object.length == 'number' &&
      Object.prototype.hasOwnProperty.call(object, 'callee') &&
      !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
      false;
  }});
  var is_arguments_1 = is_arguments.supported;
  var is_arguments_2 = is_arguments.unsupported;

  var deepEqual_1 = createCommonjsModule(function (module) {
  var pSlice = Array.prototype.slice;



  var deepEqual = module.exports = function (actual, expected, opts) {
    if (!opts) opts = {};
    // 7.1. All identical values are equivalent, as determined by ===.
    if (actual === expected) {
      return true;

    } else if (actual instanceof Date && expected instanceof Date) {
      return actual.getTime() === expected.getTime();

    // 7.3. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
    } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
      return opts.strict ? actual === expected : actual == expected;

    // 7.4. For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
    } else {
      return objEquiv(actual, expected, opts);
    }
  };

  function isUndefinedOrNull(value) {
    return value === null || value === undefined;
  }

  function isBuffer (x) {
    if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
    if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
      return false;
    }
    if (x.length > 0 && typeof x[0] !== 'number') return false;
    return true;
  }

  function objEquiv(a, b, opts) {
    var i, key;
    if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
      return false;
    // an identical 'prototype' property.
    if (a.prototype !== b.prototype) return false;
    //~~~I've managed to break Object.keys through screwy arguments passing.
    //   Converting to array solves the problem.
    if (is_arguments(a)) {
      if (!is_arguments(b)) {
        return false;
      }
      a = pSlice.call(a);
      b = pSlice.call(b);
      return deepEqual(a, b, opts);
    }
    if (isBuffer(a)) {
      if (!isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) return false;
      for (i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }
    try {
      var ka = keys(a),
          kb = keys(b);
    } catch (e) {//happens when one is a string literal and the other isn't
      return false;
    }
    // having the same number of owned properties (keys incorporates
    // hasOwnProperty)
    if (ka.length != kb.length)
      return false;
    //the same set of keys (although not necessarily the same order),
    ka.sort();
    kb.sort();
    //~~~cheap key test
    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] != kb[i])
        return false;
    }
    //equivalent values for every corresponding key, and
    //~~~possibly expensive deep test
    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!deepEqual(a[key], b[key], opts)) return false;
    }
    return typeof a === typeof b;
  }
  });

  const makeId = () => {
    let text = '';
    const possible =
  		'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 8; i += 1) {
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
  };

  function getOrigin() {
    if (!window.location.origin) {
      return (window.location.origin =
  			window.location.protocol +
  			'//' +
  			window.location.hostname +
  			(window.location.port ? ':' + window.location.port : ''));
    }
    return window.location.origin;
  }

  function absolutePath(urlString) {
    let normalizedUrl;
    const absoluteReg = new RegExp('^(?:[a-z]+:)?//', 'i');

    if (absoluteReg.test(urlString)) {
      // is absolute
      normalizedUrl = urlString;
    } else {
      if (urlString.indexOf('/') === 0 && urlString.indexOf('//') !== 0) {
        normalizedUrl = getOrigin() + urlString;
      } else {
        const paths = window.location.pathname.split('/');
        paths.pop();
        normalizedUrl = getOrigin() + paths.join('/') + '/' + urlString;
      }
    }
    return normalizedUrl;
  }

  function getPath(path, resource, options) {
    const pathIsRelative =
  		path.indexOf('http://') === -1 &&
  		path.indexOf('https://') === -1 &&
  		path.charAt(0) !== '/';

    // resolve relative paths
    if (pathIsRelative) {
      if (resource.base) {
        if (resource.base.substring(0, 2) === '##')
          resource.base = options.baseMap[resource.base];

        path = resource.base + path;
      } else if (options && options.base) {
        path = options.base + path;
      }
    }
    // create unique absolute path
    const normalizedPath = absolutePath(path);

    return normalizedPath;
  }

  const getResourcesFromDOM = (selector, options) => {
    // thats an array of all resources found in the dom
    let resources = [];
    // Array of HTML elements with a dataset "resources"
    let domResources = null;
    // if no selector is specified the scope is the whole document
    if (selector !== '') {
      const container = document.querySelector(selector);
      domResources = [].slice.call(
          container.querySelectorAll('[data-resources]')
      );
    } else {
      domResources = [].slice.call(document.querySelectorAll('[data-resources]'));
    }
    for (const newResource of domResources) {
      const obj = {};
      // evaluating data attribute string
      obj.resources = eval(newResource.dataset.resources);
      // normalize path
      for (const key in obj.resources) {
        const resourceObj = obj.resources[key];
        resourceObj.id = makeId();
        for (const pathKey in resourceObj.paths) {
          const path = resourceObj.paths[pathKey];
          obj.resources[key].paths[pathKey];
          obj.resources[key].paths[pathKey] = getPath(path, resourceObj, options);
        }
        if (resourceObj.dependsOn) {
          for (const dependsOnKey in resourceObj.dependsOn) {
            const path = resourceObj.dependsOn[dependsOnKey];
            obj.resources[key].dependsOn[dependsOnKey] = getPath(
                path,
                resourceObj,
                options
            );
          }
        }
      }
      // resource or combination is new
      let isNew = true;
      // find duplicates 👭
      if (resources.length > 0) {
        for (const resource of resources) {
          // TODO ⚠️ Thats a bug right here because of unique ids
          if (deepEqual_1(resource.resources, obj.resources)) {
            // if not new set to false, add class and break
            newResource.classList.add(`resourceLoader-${resource.id}`);
            isNew = false;
            break;
          }
        }
      }
      if (isNew) {
        obj.id = makeId();
        newResource.classList.add(`resourceLoader-${obj.id}`);
        resources = produce(resources, draftState => {
          draftState.push(obj);
        });
      }
    }
    return resources;
  };

  /**
   * VI Resource Loader v1.3.0
   * For documentation see:
   * https://github.com/biotope/biotope-resource-loader
   */

  const checkDependencies = resources => {
    const allPaths = [];
    const dependencies = [];
    // loop over resources object
    for (const resource of resources) {
      // take every resource object and loop over it's path's
      for (const paths of resource.resources) {
        // add path to allPaths
        for (const path of paths.paths) {
          allPaths.push(path);
        }
        // if has a dependency add it
        if (paths.dependsOn) {
          for (const dependency of paths.dependsOn) {
            dependencies.push(dependency);
          }
        }
      }
    }
    // check if dependencies are resolvable
    for (const dependency of dependencies) {
      if (allPaths.indexOf(dependency) === -1) {
        console.error(`⚠️ ERROR ${dependency} not resolvable.`);
      }
    }
  };

  const checkDependency = (dependents, requests) => {
    for (const d of dependents) {
      const result = requests.find(r => r.path === d);
      if (result === undefined) {
        // not all dependencies are lined up
        return false;
      }
    }
    // all dependencies are lined up
    return true;
  };

  const uniquePath = (requests, path, hasDependencies, sourceId, id) => {
    let req = requests;
    const result = req.findIndex(req => req.path === path);
    if (result === -1) {
      req = produce(req, draftState => {
        draftState.push({
          path,
          hasDependencies,
          sourceIds: [sourceId],
          packageIds: [id]
        });
      });
    } else {
      req = produce(req, draftState => {
        draftState[result].sourceIds.push(sourceId);
        draftState[result].packageIds.push(id);
      });
    }
    return req;
  };

  const addToQueue = (componentResources, requests = [], counter = 0) => {
    // recursive function to get load order
    let req = requests;
    const el = componentResources[0];
    let arr = componentResources;
    let i = counter; // counter counts up every unsuccessful reordering and resets itself on success.
    // if first element has depndecies and dependencies are not in load order yet and the total length of the array is greater/equal to 2 + counter
    if (
      el.dependsOn &&
  		checkDependency(el.dependsOn, req) === false &&
  		arr.length >= 2 + counter
    ) {
      i = i + 1; // counter get up
      const current = arr[0];
      const next = arr[i];
      arr = produce(arr, draftState => {
        draftState[0] = next;
        draftState[i] = current;
      });
    } else {
      // first item get's removed
      arr = produce(arr, draftState => {
        draftState.splice(0, 1);
      });
      // reset counter
      i = 0;
      let hasDependencies = false;
      if (el.dependsOn && el.dependsOn.length > 0) {
        hasDependencies = true;
      }
      // push all paths
      for (const p of el.paths) {
        req = uniquePath(req, p, hasDependencies, el.sourceId, el.id);
      }
    }
    // if array not empty go for it again 🏃‍
    if (arr.length !== 0) {
      return addToQueue(arr, req, i);
    } else {
      // return ordered requests.
      return req;
    }
  };

  function getComponentResources(resources) {
    let flatten = [];
    for (const resource of resources) {
      for (const componentResource of resource.resources) {
        const componentResourceClone = Object.assign({}, componentResource);
        componentResourceClone.sourceId = resource.id;
        flatten = produce(flatten, draftState => {
          draftState.push(componentResourceClone);
        });
      }
    }
    return flatten;
  }

  const updateComponentResources = (readyResources, pkg) => {
    let ready = produce(readyResources, draftState => draftState);
    for (const readyComponentPkg in ready) {
      const { id, resources } = ready[readyComponentPkg];
      if (id === pkg.sourceId) {
        for (const pkgKey in resources) {
          if (pkg.id === resources[pkgKey].id) {
            ready = produce(ready, draftState => {
              draftState[readyComponentPkg].resources.splice(pkgKey, 1);
            });
            const updatedResources = ready[readyComponentPkg].resources;
            if (updatedResources.length === 0) {
              const e = new CustomEvent('componentReady', { detail: id });
              document.dispatchEvent(e);
            }
          }
        }
      }
    }
    return ready;
  };

  let debug = null;

  const defaults = {
    container: '', // css selector for document.querySelector
    readyEvent: 'resourcesReady' // needs to be a string
  };

  let resources = [];

  // global options
  let options = null;

  const resourceLoader = customOptions => {
    options = Object.assign({}, defaults, customOptions);
    debug = options.debug ? options.debug : true;

    resources = getResourcesFromDOM(options.container, options);
    // 👷‍ add resources from options
    // ⚠️ that could be buggy, or at least it will not fire any events atm
    if (options.resources) {
      resources.unshift({ resources: options.resources });
    }

    checkDependencies(resources);

    const componentResources = getComponentResources(resources);
    const requests = addToQueue(componentResources);
    getPackages(requests);
    console.log(requests);
    // clone objects
    let readyResources = produce(resources, draftState => draftState);
    let readyComponentResources = produce(
        componentResources,
        draftState => draftState
    );
    document.addEventListener('packageLoaded', e => {
      // loop through packages of components
      for (const pkgKey in readyComponentResources) {
        const pkg = readyComponentResources[pkgKey];
        if (pkg.dependsOn && pkg.dependsOn.length > 0) {
          const index = pkg.dependsOn.indexOf(e.detail.path);
          if (index > -1) {
            readyComponentResources = produce(
                readyComponentResources,
                draftState => {
                  draftState[pkgKey].dependsOn.splice(index, 1);
                }
            );
            const updatedPkg = readyComponentResources[pkgKey];
            if (updatedPkg.dependsOn.length === 0) {
              getPackages(addToQueue([updatedPkg]), true);
            }
          }
        } else {
          const index = pkg.paths.indexOf(e.detail.path);
          if (index > -1) {
            readyComponentResources = produce(
                readyComponentResources,
                draftState => {
                  draftState[pkgKey].paths.splice(index, 1);
                }
            );
            const updatedPkg = readyComponentResources[pkgKey];
            if (updatedPkg.paths.length === 0) {
              readyResources = updateComponentResources(readyResources, pkg);
            }
          }
        }
      }
    });
    let counter = 0;
    document.addEventListener('componentReady', e => {
      console.log(`component with id: ${e.detail} ready`);
      counter = counter + 1;
      if (counter === readyResources.length) {
        const ev = new CustomEvent('resourcesReady');
        document.dispatchEvent(ev);
      }
    });
    document.addEventListener('resourcesReady', e => {
      console.log('all resources loaded');
    });
  };

  return resourceLoader;

})));
